---
title: Iteration 2 - Diffie-Hellman Key Exchange

date: '3rd January 2024'
description: Chat Application Security Analysis - Part 4
---
#### Chat Application Security Analysis - Part 4
---
[Iteration 2 source code](https://github.com/sohumshah2/chatapp/tree/e131140cf473fd4b484b2301f63faf1041412a11)

Let’s begin thinking about encryption. We want two users to be able to exchange messages securely over the internet, but eavesdroppers may be listening in and attempting to tamper with the data. Traditional encryption algorithms use a single secret key for both encryption and decryption, but securely sharing this key is a challenge. Sending the key over the same insecure channel as the messages wouldn’t work, as eavesdroppers could simply intercept it. Furthermore, it may be impractical for the two users to meet in person and agree upon a shared key in advance. So how can two users agree on a shared secret, while communicating openly? 

### One way functions
To address this problem, let’s consider the idea of one way functions. A one-way function is easy to compute in one direction, but given an output, it is difficult to find a corresponding input. For example, it is easy to multiply two prime numbers together and obtain the product, but given the product, it is very difficult to obtain the prime numbers. We want to use one-way functions in a way that allows both users to perform straightforward computations, while making it very challenging for an eavesdropper to reverse-engineer the process.

### Modular arithmetic and the discrete logarithm problem
One such ‘one-way function’ is the discrete logarithm problem. This problem uses modular arithmetic. Imagine you have a standard 12 hour analog clock. Suppose it is 11 o’clock and you want to know the time in 4 hours. Of course, it will be 3 o’clock. Really, 11 + 4 is 15, but our clock only has 12 hours. So, we wrap around to 1 whenever we need to go past 12. 11 + 1 is 12. 12 + 1 is 1. Now, 1 + 1 is 2. 2 + 1 = 3. We’ve added 4 to 11 to obtain 3. 

Modular arithmetic is a way of working with numbers that wrap around in this cyclic manner. We can see that 15 is related to 3 on this clock in the sense that it has the same position when we wrap around. Similarly, we could add another 12 to 15, to obtain 27. This can be visualised as moving from the ‘15’ position by 12 hours around the entire clock, returning to the same position. Hence, 12, 15 and 27 are all related on this clock. We say that 15 is congruent to 3, modulo 12. It is also congruent to 27 modulo 12. 12 here is called the ‘modulus’.

Let’s make the input number a power. It turns out that calculating something like 2x mod 523 for some known x is easy and can be done quickly, but given the output, it is very difficult to find x. 
2423 mod 523 for instance can be quickly computed to 136, but given the output of 136, it is difficult to find the input, 423. Maybe not so difficult with these small numbers as there are only 523 numbers to test (powers of 2 from 0 to 522), but if the modulus was hundreds or thousands of digits long, it would be very difficult.


It is important that the modulus and power is chosen carefully.

Let’s use a prime modulus, say 7, and a base of 2. Let’s look at the powers of 2 modulo 7.

<Table
  data={[
    { superscript: '21 mod 7', item1: '2 mod 7', item2: '2 = 0 × 7 + 2', item3: '2' },
    { superscript: '22 mod 7', item1: '4 mod 7', item2: '4 = 0 × 7 + 4', item3: '4' },
    { superscript: '23 mod 7', item1: '8 mod 7', item2: '8 = 1 × 7 + 1', item3: '1' },
    { superscript: '24 mod 7', item1: '16 mod 7', item2: '16 = 2 × 7 + 2', item3: '2' },
    { superscript: '25 mod 7', item1: '32 mod 7', item2: '32 = 4 × 7 + 4', item3: '4' },
    { superscript: '26 mod 7', item1: '64 mod 7', item2: '64 = 9 × 7 + 1', item3: '1' },
  ]}
/>

Notice that the outputs are not unique. If I told you that 2<sup>x</sup> mod 7 = 2, and you tried to brute force and manually calculate powers of 2 modulo 7 until you found an answer of 2, each try would have a probability of ⅓, not ⅙. We want to use a base that results in a uniformly distributed output, in other words, all numbers from 0 to the modulus minus one should appear. Such a base is called a primitive root of the prime modulus. Three, for instance, is a primitive root of seven, as confirmed in the table below, where the outputs are unique.

<Table
  data={[
    { superscript: '31 mod 7', item1: '3 mod 7', item2: '3 = 0 × 7 + 3', item3: '3' },
    { superscript: '32 mod 7', item1: '9 mod 7', item2: '9 = 1 × 7 + 2', item3: '2' },
    { superscript: '33 mod 7', item1: '27 mod 7', item2: '27 = 3 × 7 + 6', item3: '6' },
    { superscript: '34 mod 7', item1: '81 mod 7', item2: '81 = 11 × 7 + 4', item3: '4' },
    { superscript: '35 mod 7', item1: '243 mod 7', item2: '243 = 34 × 7 + 5', item3: '5' },
    { superscript: '36 mod 7', item1: '729 mod 7', item2: '729 = 104 × 7 + 1', item3: '1' },
  ]}
/>

Using a prime modulus that is hundreds of digits long, and a corresponding base that is a primitive root, calculating the output can be done in milliseconds, but given the output, working out the input power would take hundreds or thousands of years, even with significant computing power. This problem is known as the discrete logarithm problem, and it is computationally intractable.

### The Diffie-Hellman solution
We want to utilise modular exponentiation as a building block towards a key exchange protocol. By sharing only the result of a modular exponentiation, it will be essentially impossible for an eavesdropper to determine the input.

Suppose Alice and Bob want to establish a shared secret over the internet. They both agree on a large prime number, p, and a primitive root of p, we’ll call g. These values will be public so an eavesdropper would know them. Alice computes g<sup>a</sup> mod p and Bob computes g<sup>b</sup> mod p. They exchange these computed values over the internet, exposing them to eavesdroppers. Now, Alice takes the received g<sup>b</sup> mod p, and raises it to the power of a, before calculating the result modulo p. Similarly, Bob takes the received g<sup>a</sup> mod p, raises it to b and calculates the result modulo p. Using modular arithmetic rules, we can deduce that (g<sup>a</sup> mod p)<sup>b</sup> mod p = (g<sup>b</sup> mod p)<sup>a</sup> mod p = g<sup>ab</sup> mod p.

Hence, Alice and Bob have agreed on a shared key, g<sup>ab</sup> mod p! Let’s consider what an eavesdropper knows. They know the publicly available values g and p, as well as the transmitted numbers g<sup>a</sup> mod p and g<sup>b</sup> mod p. If an eavesdropper knows the protocol used, they know the formula for the transmitted numbers. They know the base and the modulus, but they don’t know the powers, a and b. In order to work out the shared key, g<sup>ab</sup> mod p, they would need to determine either a or b. If they can work out a, for instance, they can then just follow the procedure Alice used, raising g<sup>b</sup> mod p by a, and computing the result modulo p, to determine the shared key. However, calculating a or b is precisely the discrete logarithm problem, which is infeasible to solve with the way we’ve chosen our parameters. 

This solution is known as Diffie-Hellman key exchange, developed by Whitfield Diffie and Martin Hellman in 1976. It offers an efficient and secure method for two parties to agree upon a shared secret key, communicating over an insecure channel.

### Implementing Diffie-Hellman
We implement the Diffie-Hellman key exchange protocol in a JS file, diffieHellman.js.

#### Logjam vulnerability
The Logjam vulnerability is a vulnerability that affects the Diffie-Hellman protocol when 512 bit or smaller prime numbers are used. The vulnerability utilises the number sieve algorithm, which is considered the most effective algorithm to find discrete logarithms. Note that it is still exponential. This algorithm consists of four computationally intensive steps, but the first three only depend on the value of p, and not the other parameters. Hence, the results of the first three steps could be precomputed and used to quickly solve any discrete log problem with that modulus p. As it turned out, 512 bit modulus values were commonly used on the internet and in fact very few unique values were used, so this attack could facilitate the decryption of much of internet traffic. The authors of the vulnerability also estimated that the attack, if conducted on larger, 1024 bit primes, would cost some hundreds of millions of dollars for the precomputation, which they noted was viable for a nation-state agency such as the NSA. They recommended the use of 2048 bit primes or larger, or consider switching to a different number system to conduct the Diffie-Hellman protocol on, such as elliptical curves.

#### Choosing parameters
The Logjam vulnerability highlights the risks associated with choosing and reusing small prime numbers.
However, so long as a large enough prime number is chosen, the vulnerability will be infeasible and so the prime can be reused safely. To ensure mathematically secure parameters are chosen, I used the 3072-bit group posted on RFC 3526, with the prime p and generator g values shown below. These values were generated following strict criteria and have been analysed to ensure they are safe to use.

```javascript
// RFC 3526 - 3072-bit MODP Group 15
const pString = `
FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
43DB5BFC E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF
`;
const pStringNoWhitespace = pString.replace(/\s/g, '')
const p = BigInt('0x' + pStringNoWhitespace)
const g = BigInt(2)
```

#### Modular exponentiation
The primary mathematical computation involved in Diffie-Hellman key exchange is modular exponentiation, in other words, raising a base to some power and computing the result modulo p.

The naive way to implement this is to keep multiplying the base by itself, and then floor dividing by the modulus. However, this is slow and the result before we floor divide will be massive if we use large inputs, taking up enormous amounts of memory. 

Instead we can use the principle that (a × b) mod m = ((a mod m) × (b mod m)) mod m. Thus, we can take the result mod m after each multiplication to ensure the numbers remain small.

To improve efficiency, we can use the  ‘square and multiply’ technique, which we discuss looking at the following code.

#### Efficient modular exponentiation
```javascript
// decomposeIntoPowersOf2 Function

// Decompose a positive integer into its
// powers of 2 representation, as an array
let decomposeIntoPowersOf2 = (num) => {
    const powersOf2 = []
    let i = BigInt(1)
    let log_i = 0
    while (i <= num) {
        if (i & num) {
            powersOf2.push(log_i)
        }
        i <<= BigInt(1)
        log_i++
    }
    return powersOf2
}
```
This helper function performs a bitwise AND operation between increasing powers of 2 and the input number and determines when they match. For instance, if the input number is 42, the computer represents this in binary as 101010. We do a bitwise AND with 1 which will evaluate to zero, since the least significant bit in the input is 0. We then left shift 1, so it becomes 10. We then do a bitwise AND with the input, which evaluates to 1 since the second least significant bit in the input is 1. Hence we know that 2 to the power of 1 is in the number, so we add the power, 1, to the output array. We continue, ultimately returning an array containing 1, 3 and 5. This makes sense since 42 equals  2<sup>5</sup> + 2<sup>3</sup> + 2<sup>1</sup>. The usage of bitwise operations makes the function very efficient. 

```javascript
// compute Function

// Compute (base^power) % mod using the
// 'square and multiply' technique
let compute = (base, decomposedPower, mod) => {
    let prev = BigInt(base) % BigInt(mod)
    let res = BigInt(1)
    let j = BigInt(0)

    if (decomposedPower[0] == 0) {
        res = prev
        j++
    }

    let i = 1

    while (i <= decomposedPower[decomposedPower.length - 1]) {
        prev = (BigInt(prev) ** BigInt(2)) % BigInt(mod)
        if (decomposedPower[j] === i) {
            res = (res * prev) % mod
        }
        if (decomposedPower[j] === i) {
            res = (res * prev) % mod
        }
        if (decomposedPower[j] <= i) {
            j++
        }
        i++
    }
    return res
}
```
The compute function raises ‘base’ to the power of the number represented by the ‘decomposedPower’ array, modulo ‘mod’. This is the primary mathematical computation involved in Diffie-Hellman key exchange. 

The function calculates increasing powers of 2 modulo ‘mod’ and stores them in ‘prev’. When a power of 2 is present in the decomposedPower, ‘res’ is multiplied by ‘prev’ and the result modulo n is stored. This efficiently performs modular exponentiation.

Let’s run through the calculation of  7<sup>11</sup> mod 5. 
- We first decompose the power, 11 into a sum of powers of 2. 
- Note that 11 =  2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup>. 
  - The decomposeIntoPowersOf2 function with the input of 11 will return an array, [0, 1, 3].
- Hence, 7<sup>11</sup> = 7<sup>2^3 + 2^1 + 2^0</sup> = 7<sup>2^3</sup> × 7<sup>2^1</sup> × 7<sup>2^0</sup>.
- Now, we can apply the ‘square and multiply’ technique. Set res = 1.
- 7<sup>2^0</sup> mod 5 = 7 mod 5 = **2**.
  - res ×= 2 mod 5, so res = 2.
- 7<sup>2^1</sup> mod 5 = (7<sup>2^0</sup> mod 5)<sup>2</sup> mod 5 = **2**<sup>2</sup> mod 5 = **4**.
  - res ×= 4 mod 5, so res = 8 mod 5 = 3.
- 7<sup>2^2</sup> mod 5 = (7<sup>2^1</sup> mod 5)<sup>2</sup> mod 5 = **4**<sup>2</sup> mod 5 = **1**.
  - res remains unchanged since 11 does not contain 2<sup>2</sup>.
- 7<sup>2^3</sup> mod 5 = (7<sup>2^2</sup> mod 5)<sup>2</sup> mod 5 = **1**<sup>2</sup> mod 5 = **1**.
  - res ×= 1 mod 5, so res = 3.
- Hence, 7<sup>11</sup> mod 5 = res = 3.

#### Generating keys
```javascript
// generateKeyToSend Function

export const generateKeyToSend = () => {
    const aArray = secureRandom(32, {type: 'Array'})
    const binaryString = aArray.map(value => {
      value.toString(2).padStart(8, '8')
    }).join('')

    // private key 'aBigInt' is a random number
    const aBigInt = BigInt('0b' + binaryString)

    // public key 'A' = g^a mod p
    const A = compute(g, decomposeIntoPowersOf2(aBigInt), p) 

    // return the private and public keys. 
    // Note that only the public should be transmitted over the internet.
    return {aBigInt, A} 
}
```

We use a library to generate a random 32 byte (256 bit) private value. We then use the compute function to raise g to this private value modulo p. We return this result along with the private value.

#### Computing the shared secret
```javascript
// computeSymmetricKey Function

export const computeSymmetricKey = (aBigInt, B) => {
    return new Promise((resolve, reject) => {
        const keyInput = compute(
          BigInt(B), 
          decomposeIntoPowersOf2(aBigInt), 
          p
        );
        const keyInputArray = bigintToUint8Array(keyInput);
        const hash = 'SHA-256';
        const length = 32;
        const info = '';
        const salt = new Uint8Array();
        hkdf.compute(keyInputArray, hash, length, info, salt)
            .then((derivedKey) => {
                const aesKey = uint8ArrayToHexString(derivedKey.key);
                resolve(aesKey);
            })
            .catch(reject);
    });
}
```

We use our private value, a, as well as the received public value, B, which is just g<sup>b</sup> mod p. We raise ‘B’ to ‘a’ mod ‘p’ to obtain the shared key, g<sup>ab</sup> mod p. 

#### Key derivation functions
We then use a key derivation function (KDF) to derive a key suitable for the AES-256 encryption algorithm. In the chat app, we use the HMAC-based key derivation function (HKDF). The KDF removes any patterns that may be present in the shared key gab mod p, turning it into a key with a higher level of entropy.

HKDF essentially hashes the input aesKey with a cryptographic hashing algorithm. The hash is then iteratively expanded into a desired length, 256 bits in our case, by applying the HMAC algorithm multiple times, with each iteration extending the result and feeding it back into the HMAC algorithm. The HMAC (hash-based message authentication code) algorithm is described later in this report.

### Integrating Diffie-Hellman into the chat app
Let’s have a look at how these two functions (generateKeyToSend, computeSymmetricKey) are used in the chat app.

```javascript
const handleSendMessage = () => {

  // Conduct a Diffie-Hellman handshake if the receiver is new
  if (connectionEstablishedWithRef.current !== receiverRef.current) {

    // Notify old receiver that the connection has closed
    if (connectionEstablishedWithRef.current !== '') {
      socket.emit("sendMessage", {
        sender: senderRef.current, 
        receiver: connectionEstablishedWithRef.current, 
        message: aes256.encrypt(aesKeyRef.current, 'seashells_end'), 
        handshake: true
      });
    }
    setWaitingForHandshakeResponse(true)
    const dh = generateKeyToSend()
    setDiffieHellmanPrivate(dh.aBigInt)
    setDiffieHellmanPublic(dh.A)
    const handshakeMessage = {
      'sender': senderRef.current,
      'receiver': receiverRef.current,
      'message': dh.A.toString(),
      'handshake': true,
    }

    // Send handshake message and wait for a reply
    establishConnection2(handshakeMessage).then((handshakeReply) => {
        // When we receive the handshake reply, compute the shared key
        setConnectionEstablishedWith(handshakeReply.sender)
        setWaitingForHandshakeResponse(false)
        setDiffieHellmanReceiverPublic(BigInt(handshakeReply.message))
        computeSymmetricKey(
          diffieHellmanPrivateRef.current, 
          BigInt(handshakeReply.message)
        ).then((aesKey) => {
          setAesKey(aesKey)
    
          // Send the encrypted message
          const encryptedMessage = aes256.encrypt(
            aesKeyRef.current, 
            `seashells_${message}`
          )
          socket.emit("sendMessage", {
            sender: senderRef.current, 
            receiver: receiverRef.current, 
            message: encryptedMessage, 
            handshake: false, 
          });
        })
    })
  }
}
```

```javascript
// Establishes a connection with a recipient 
// using a handshake mechanism.

// Returns a promise that resolves with the 
// received handshake reply message.

const establishConnection2 = (handshakeMessage) => {
  return new Promise((resolve, reject) => {

    // Helper function handles incoming broadcast messages and
    // resolves the promise when a valid handshake reply 
    // message is received for the specified sender.
    const broadcastListener = (message) => {
      if (message.receiver === senderRef.current && message.handshake) {
        resolve(message);
        socket.off('broadcastMessage', broadcastListener);
      }
    };

    // Register the broadcast listener for 'broadcastMessage' events
    socket.on('broadcastMessage', broadcastListener);

    // Send the handshake message to initiate the connection
    socket.emit('sendMessage', handshakeMessage);
  });
}
```

As demonstrated in the code snippets above, when the user clicks the send button to send a message to a new receiver, the client code calls the generateKeyToSend function to generate the Diffie Hellman parameters a and A (A = g<sup>a</sup> mod p). The public key A is then sent in a handshake message to the recipient. The recipient will respond analogously, generating b and B (B = g<sup>b</sup> mod p), and sending the public key B. The user will then call computeSymmetricKey to compute the shared key, g<sup>ab</sup> mod p and use the HKDF algorithm to derive a suitable AES key. Then the user encrypts the message with this key and sends it to the receiver.


The snippet below shows how the recipient handles an incoming handshake request. If it currently has a connection with another user, it sends a message letting them know the connection has closed and we are discarding the shared key we had established. The recipient then generates a prime number b and the public key B (B = g<sup>b</sup> mod p). They then compute the AES key and send back B. 

```javascript
// broadCastMessage Listener snippet
    
socket.on("broadcastMessage", (msg) => {
  // ...
  if (msg.handshake && msg.receiver === senderRef.current) {

    // Receiving a handshake request from a new client
    // We inform the old client that the connection has closed
    if (connectionEstablishedWithRef.current !== '') {
      socket.emit("sendMessage", {
        sender: senderRef.current, 
        receiver: connectionEstablishedWithRef.current, 
        message: aes256.encrypt(aesKeyRef.current, 'seashells_end'), 
        handshake: true
      });
    }

    // Establish parameters and compute the symmetric AES key
    setConnectionEstablishedWith(msg.sender)
    setReceiver(msg.sender)
    setDiffieHellmanReceiverPublic(msg.message)
    const dh = generateKeyToSend()
    setDiffieHellmanPrivate(dh.aBigInt)
    setDiffieHellmanPublic(dh.A)
    socket.emit("sendMessage", {
      'sender': senderRef.current,
      'receiver': msg.sender,
      'message': dh.A.toString(),
      'handshake': true,
    })
    computeSymmetricKey(dh.aBigInt, msg.message).then((aesKey) => {
      setAesKey(aesKey)
    })
  }
});
```

### Functionality
todo: continue